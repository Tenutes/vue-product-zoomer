/*! For license information please see vendorsDefault-node_modules_vue_reactivity_dist_reactivity_esm-bundler_js.bundle.js.LICENSE.txt */
"use strict";(self.webpackChunkProductZoomer=self.webpackChunkProductZoomer||[]).push([["vendorsDefault-node_modules_vue_reactivity_dist_reactivity_esm-bundler_js"],{"./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js":(e,t,n)=>{n.r(t),n.d(t,{EffectScope:()=>c,ITERATE_KEY:()=>R,ReactiveEffect:()=>k,computed:()=>et,customRef:()=>Je,deferredComputed:()=>ct,effect:()=>S,effectScope:()=>a,enableTracking:()=>O,getCurrentScope:()=>l,isProxy:()=>Pe,isReactive:()=>Te,isReadonly:()=>Ae,isRef:()=>Ie,markRaw:()=>$e,onScopeDispose:()=>h,pauseTracking:()=>M,proxyRefs:()=>Ge,reactive:()=>xe,readonly:()=>je,ref:()=>De,resetTracking:()=>T,shallowReactive:()=>Ee,shallowReadonly:()=>Me,shallowRef:()=>Ne,stop:()=>x,toRaw:()=>Ve,toRef:()=>Ue,toRefs:()=>Le,track:()=>A,trigger:()=>$,triggerRef:()=>Fe,unref:()=>Ye});var s=n("./node_modules/@vue/shared/dist/shared.esm-bundler.js");function i(e,...t){console.warn(`[Vue warn] ${e}`,...t)}let r;const o=[];class c{constructor(e=!1){this.active=!0,this.effects=[],this.cleanups=[],!e&&r&&(this.parent=r,this.index=(r.scopes||(r.scopes=[])).push(this)-1)}run(e){if(this.active)try{return this.on(),e()}finally{this.off()}else i("cannot run an inactive effect scope.")}on(){this.active&&(o.push(this),r=this)}off(){this.active&&(o.pop(),r=o[o.length-1])}stop(e){if(this.active){if(this.effects.forEach((e=>e.stop())),this.cleanups.forEach((e=>e())),this.scopes&&this.scopes.forEach((e=>e.stop(!0))),this.parent&&!e){const e=this.parent.scopes.pop();e&&e!==this&&(this.parent.scopes[this.index]=e,e.index=this.index)}this.active=!1}}}function a(e){return new c(e)}function u(e,t){(t=t||r)&&t.active&&t.effects.push(e)}function l(){return r}function h(e){r?r.cleanups.push(e):i("onScopeDispose() is called when there is no active effect scope to be associated with.")}const f=e=>{const t=new Set(e);return t.w=0,t.n=0,t},d=e=>(e.w&g)>0,_=e=>(e.n&g)>0,p=new WeakMap;let v=0,g=1;const y=[];let w;const R=Symbol("iterate"),b=Symbol("Map key iterate");class k{constructor(e,t=null,n){this.fn=e,this.scheduler=t,this.active=!0,this.deps=[],u(this,n)}run(){if(!this.active)return this.fn();if(!y.includes(this))try{return y.push(w=this),O(),g=1<<++v,v<=30?(({deps:e})=>{if(e.length)for(let t=0;t<e.length;t++)e[t].w|=g})(this):m(this),this.fn()}finally{v<=30&&(e=>{const{deps:t}=e;if(t.length){let n=0;for(let s=0;s<t.length;s++){const i=t[s];d(i)&&!_(i)?i.delete(e):t[n++]=i,i.w&=~g,i.n&=~g}t.length=n}})(this),g=1<<--v,T(),y.pop();const e=y.length;w=e>0?y[e-1]:void 0}}stop(){this.active&&(m(this),this.onStop&&this.onStop(),this.active=!1)}}function m(e){const{deps:t}=e;if(t.length){for(let n=0;n<t.length;n++)t[n].delete(e);t.length=0}}function S(e,t){e.effect&&(e=e.effect.fn);const n=new k(e);t&&((0,s.extend)(n,t),t.scope&&u(n,t.scope)),t&&t.lazy||n.run();const i=n.run.bind(n);return i.effect=n,i}function x(e){e.effect.stop()}let E=!0;const j=[];function M(){j.push(E),E=!1}function O(){j.push(E),E=!0}function T(){const e=j.pop();E=void 0===e||e}function A(e,t,n){if(!P())return;let s=p.get(e);s||p.set(e,s=new Map);let i=s.get(n);i||s.set(n,i=f());V(i,{effect:w,target:e,type:t,key:n})}function P(){return E&&void 0!==w}function V(e,t){let n=!1;v<=30?_(e)||(e.n|=g,n=!d(e)):n=!e.has(w),n&&(e.add(w),w.deps.push(e),w.onTrack&&w.onTrack(Object.assign({effect:w},t)))}function $(e,t,n,i,r,o){const c=p.get(e);if(!c)return;let a=[];if("clear"===t)a=[...c.values()];else if("length"===n&&(0,s.isArray)(e))c.forEach(((e,t)=>{("length"===t||t>=i)&&a.push(e)}));else switch(void 0!==n&&a.push(c.get(n)),t){case"add":(0,s.isArray)(e)?(0,s.isIntegerKey)(n)&&a.push(c.get("length")):(a.push(c.get(R)),(0,s.isMap)(e)&&a.push(c.get(b)));break;case"delete":(0,s.isArray)(e)||(a.push(c.get(R)),(0,s.isMap)(e)&&a.push(c.get(b)));break;case"set":(0,s.isMap)(e)&&a.push(c.get(R))}const u={target:e,type:t,key:n,newValue:i,oldValue:r,oldTarget:o};if(1===a.length)a[0]&&z(a[0],u);else{const e=[];for(const t of a)t&&e.push(...t);z(f(e),u)}}function z(e,t){for(const n of(0,s.isArray)(e)?e:[...e])(n!==w||n.allowRecurse)&&(n.onTrigger&&n.onTrigger((0,s.extend)({effect:n},t)),n.scheduler?n.scheduler():n.run())}const W=(0,s.makeMap)("__proto__,__v_isRef,__isVue"),C=new Set(Object.getOwnPropertyNames(Symbol).map((e=>Symbol[e])).filter(s.isSymbol)),K=F(),I=F(!1,!0),D=F(!0),N=F(!0,!0),Z=B();function B(){const e={};return["includes","indexOf","lastIndexOf"].forEach((t=>{e[t]=function(...e){const n=Ve(this);for(let e=0,t=this.length;e<t;e++)A(n,"get",e+"");const s=n[t](...e);return-1===s||!1===s?n[t](...e.map(Ve)):s}})),["push","pop","shift","unshift","splice"].forEach((t=>{e[t]=function(...e){M();const n=Ve(this)[t].apply(this,e);return T(),n}})),e}function F(e=!1,t=!1){return function(n,i,r){if("__v_isReactive"===i)return!e;if("__v_isReadonly"===i)return e;if("__v_raw"===i&&r===(e?t?Se:me:t?ke:be).get(n))return n;const o=(0,s.isArray)(n);if(!e&&o&&(0,s.hasOwn)(Z,i))return Reflect.get(Z,i,r);const c=Reflect.get(n,i,r);if((0,s.isSymbol)(i)?C.has(i):W(i))return c;if(e||A(n,"get",i),t)return c;if(Ie(c)){return!o||!(0,s.isIntegerKey)(i)?c.value:c}return(0,s.isObject)(c)?e?je(c):xe(c):c}}const Y=G(),q=G(!0);function G(e=!1){return function(t,n,i,r){let o=t[n];if(!e&&!Ae(i)&&(i=Ve(i),o=Ve(o),!(0,s.isArray)(t)&&Ie(o)&&!Ie(i)))return o.value=i,!0;const c=(0,s.isArray)(t)&&(0,s.isIntegerKey)(n)?Number(n)<t.length:(0,s.hasOwn)(t,n),a=Reflect.set(t,n,i,r);return t===Ve(r)&&(c?(0,s.hasChanged)(i,o)&&$(t,"set",n,i,o):$(t,"add",n,i)),a}}const H={get:K,set:Y,deleteProperty:function(e,t){const n=(0,s.hasOwn)(e,t),i=e[t],r=Reflect.deleteProperty(e,t);return r&&n&&$(e,"delete",t,void 0,i),r},has:function(e,t){const n=Reflect.has(e,t);return(0,s.isSymbol)(t)&&C.has(t)||A(e,"has",t),n},ownKeys:function(e){return A(e,"iterate",(0,s.isArray)(e)?"length":R),Reflect.ownKeys(e)}},J={get:D,set:(e,t)=>(console.warn(`Set operation on key "${String(t)}" failed: target is readonly.`,e),!0),deleteProperty:(e,t)=>(console.warn(`Delete operation on key "${String(t)}" failed: target is readonly.`,e),!0)},L=(0,s.extend)({},H,{get:I,set:q}),Q=(0,s.extend)({},J,{get:N}),U=e=>e,X=e=>Reflect.getPrototypeOf(e);function ee(e,t,n=!1,s=!1){const i=Ve(e=e.__v_raw),r=Ve(t);t!==r&&!n&&A(i,"get",t),!n&&A(i,"get",r);const{has:o}=X(i),c=s?U:n?We:ze;return o.call(i,t)?c(e.get(t)):o.call(i,r)?c(e.get(r)):void(e!==i&&e.get(t))}function te(e,t=!1){const n=this.__v_raw,s=Ve(n),i=Ve(e);return e!==i&&!t&&A(s,"has",e),!t&&A(s,"has",i),e===i?n.has(e):n.has(e)||n.has(i)}function ne(e,t=!1){return e=e.__v_raw,!t&&A(Ve(e),"iterate",R),Reflect.get(e,"size",e)}function se(e){e=Ve(e);const t=Ve(this);return X(t).has.call(t,e)||(t.add(e),$(t,"add",e,e)),this}function ie(e,t){t=Ve(t);const n=Ve(this),{has:i,get:r}=X(n);let o=i.call(n,e);o?Re(n,i,e):(e=Ve(e),o=i.call(n,e));const c=r.call(n,e);return n.set(e,t),o?(0,s.hasChanged)(t,c)&&$(n,"set",e,t,c):$(n,"add",e,t),this}function re(e){const t=Ve(this),{has:n,get:s}=X(t);let i=n.call(t,e);i?Re(t,n,e):(e=Ve(e),i=n.call(t,e));const r=s?s.call(t,e):void 0,o=t.delete(e);return i&&$(t,"delete",e,void 0,r),o}function oe(){const e=Ve(this),t=0!==e.size,n=(0,s.isMap)(e)?new Map(e):new Set(e),i=e.clear();return t&&$(e,"clear",void 0,void 0,n),i}function ce(e,t){return function(n,s){const i=this,r=i.__v_raw,o=Ve(r),c=t?U:e?We:ze;return!e&&A(o,"iterate",R),r.forEach(((e,t)=>n.call(s,c(e),c(t),i)))}}function ae(e,t,n){return function(...i){const r=this.__v_raw,o=Ve(r),c=(0,s.isMap)(o),a="entries"===e||e===Symbol.iterator&&c,u="keys"===e&&c,l=r[e](...i),h=n?U:t?We:ze;return!t&&A(o,"iterate",u?b:R),{next(){const{value:e,done:t}=l.next();return t?{value:e,done:t}:{value:a?[h(e[0]),h(e[1])]:h(e),done:t}},[Symbol.iterator](){return this}}}}function ue(e){return function(...t){{const n=t[0]?`on key "${t[0]}" `:"";console.warn(`${(0,s.capitalize)(e)} operation ${n}failed: target is readonly.`,Ve(this))}return"delete"!==e&&this}}function le(){const e={get(e){return ee(this,e)},get size(){return ne(this)},has:te,add:se,set:ie,delete:re,clear:oe,forEach:ce(!1,!1)},t={get(e){return ee(this,e,!1,!0)},get size(){return ne(this)},has:te,add:se,set:ie,delete:re,clear:oe,forEach:ce(!1,!0)},n={get(e){return ee(this,e,!0)},get size(){return ne(this,!0)},has(e){return te.call(this,e,!0)},add:ue("add"),set:ue("set"),delete:ue("delete"),clear:ue("clear"),forEach:ce(!0,!1)},s={get(e){return ee(this,e,!0,!0)},get size(){return ne(this,!0)},has(e){return te.call(this,e,!0)},add:ue("add"),set:ue("set"),delete:ue("delete"),clear:ue("clear"),forEach:ce(!0,!0)};return["keys","values","entries",Symbol.iterator].forEach((i=>{e[i]=ae(i,!1,!1),n[i]=ae(i,!0,!1),t[i]=ae(i,!1,!0),s[i]=ae(i,!0,!0)})),[e,n,t,s]}const[he,fe,de,_e]=le();function pe(e,t){const n=t?e?_e:de:e?fe:he;return(t,i,r)=>"__v_isReactive"===i?!e:"__v_isReadonly"===i?e:"__v_raw"===i?t:Reflect.get((0,s.hasOwn)(n,i)&&i in t?n:t,i,r)}const ve={get:pe(!1,!1)},ge={get:pe(!1,!0)},ye={get:pe(!0,!1)},we={get:pe(!0,!0)};function Re(e,t,n){const i=Ve(n);if(i!==n&&t.call(e,i)){const t=(0,s.toRawType)(e);console.warn(`Reactive ${t} contains both the raw and reactive versions of the same object${"Map"===t?" as keys":""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`)}}const be=new WeakMap,ke=new WeakMap,me=new WeakMap,Se=new WeakMap;function xe(e){return e&&e.__v_isReadonly?e:Oe(e,!1,H,ve,be)}function Ee(e){return Oe(e,!1,L,ge,ke)}function je(e){return Oe(e,!0,J,ye,me)}function Me(e){return Oe(e,!0,Q,we,Se)}function Oe(e,t,n,i,r){if(!(0,s.isObject)(e))return console.warn(`value cannot be made reactive: ${String(e)}`),e;if(e.__v_raw&&(!t||!e.__v_isReactive))return e;const o=r.get(e);if(o)return o;const c=(a=e).__v_skip||!Object.isExtensible(a)?0:function(e){switch(e){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}((0,s.toRawType)(a));var a;if(0===c)return e;const u=new Proxy(e,2===c?i:n);return r.set(e,u),u}function Te(e){return Ae(e)?Te(e.__v_raw):!(!e||!e.__v_isReactive)}function Ae(e){return!(!e||!e.__v_isReadonly)}function Pe(e){return Te(e)||Ae(e)}function Ve(e){const t=e&&e.__v_raw;return t?Ve(t):e}function $e(e){return(0,s.def)(e,"__v_skip",!0),e}const ze=e=>(0,s.isObject)(e)?xe(e):e,We=e=>(0,s.isObject)(e)?je(e):e;function Ce(e){P()&&((e=Ve(e)).dep||(e.dep=f()),V(e.dep,{target:e,type:"get",key:"value"}))}function Ke(e,t){(e=Ve(e)).dep&&z(e.dep,{target:e,type:"set",key:"value",newValue:t})}function Ie(e){return Boolean(e&&!0===e.__v_isRef)}function De(e){return Ze(e,!1)}function Ne(e){return Ze(e,!0)}function Ze(e,t){return Ie(e)?e:new Be(e,t)}class Be{constructor(e,t){this._shallow=t,this.dep=void 0,this.__v_isRef=!0,this._rawValue=t?e:Ve(e),this._value=t?e:ze(e)}get value(){return Ce(this),this._value}set value(e){e=this._shallow?e:Ve(e),(0,s.hasChanged)(e,this._rawValue)&&(this._rawValue=e,this._value=this._shallow?e:ze(e),Ke(this,e))}}function Fe(e){Ke(e,e.value)}function Ye(e){return Ie(e)?e.value:e}const qe={get:(e,t,n)=>Ye(Reflect.get(e,t,n)),set:(e,t,n,s)=>{const i=e[t];return Ie(i)&&!Ie(n)?(i.value=n,!0):Reflect.set(e,t,n,s)}};function Ge(e){return Te(e)?e:new Proxy(e,qe)}class He{constructor(e){this.dep=void 0,this.__v_isRef=!0;const{get:t,set:n}=e((()=>Ce(this)),(()=>Ke(this)));this._get=t,this._set=n}get value(){return this._get()}set value(e){this._set(e)}}function Je(e){return new He(e)}function Le(e){Pe(e)||console.warn("toRefs() expects a reactive object but received a plain one.");const t=(0,s.isArray)(e)?new Array(e.length):{};for(const n in e)t[n]=Ue(e,n);return t}class Qe{constructor(e,t,n){this._object=e,this._key=t,this._defaultValue=n,this.__v_isRef=!0}get value(){const e=this._object[this._key];return void 0===e?this._defaultValue:e}set value(e){this._object[this._key]=e}}function Ue(e,t,n){const s=e[t];return Ie(s)?s:new Qe(e,t,n)}class Xe{constructor(e,t,n){this._setter=t,this.dep=void 0,this._dirty=!0,this.__v_isRef=!0,this.effect=new k(e,(()=>{this._dirty||(this._dirty=!0,Ke(this))})),this.__v_isReadonly=n}get value(){const e=Ve(this);return Ce(e),e._dirty&&(e._dirty=!1,e._value=e.effect.run()),e._value}set value(e){this._setter(e)}}function et(e,t){let n,i;const r=(0,s.isFunction)(e);r?(n=e,i=()=>{console.warn("Write operation failed: computed value is readonly")}):(n=e.get,i=e.set);const o=new Xe(n,i,r||!i);return t&&(o.effect.onTrack=t.onTrack,o.effect.onTrigger=t.onTrigger),o}var tt;const nt=Promise.resolve(),st=[];let it=!1;const rt=()=>{for(let e=0;e<st.length;e++)st[e]();st.length=0,it=!1};class ot{constructor(e){let t;this.dep=void 0,this._dirty=!0,this.__v_isRef=!0,this[tt]=!0;let n=!1,s=!1;this.effect=new k(e,(e=>{if(this.dep){if(e)t=this._value,n=!0;else if(!s){const e=n?t:this._value;s=!0,n=!1,i=()=>{this.effect.active&&this._get()!==e&&Ke(this),s=!1},st.push(i),it||(it=!0,nt.then(rt))}for(const e of this.dep)e.computed&&e.scheduler(!0)}var i;this._dirty=!0})),this.effect.computed=!0}_get(){return this._dirty?(this._dirty=!1,this._value=this.effect.run()):this._value}get value(){return Ce(this),Ve(this)._get()}}function ct(e){return new ot(e)}tt="__v_isReadonly"}}]);